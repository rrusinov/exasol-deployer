{% raw -%}
#!/usr/bin/env bash
# This script creates stable /dev/exasol_data_* symlinks for data volumes
# It runs on boot via systemd to ensure symlinks persist across reboots
#
# Generated by Ansible - DO NOT EDIT MANUALLY
# Volume IDs: {% endraw %}{{ volume_ids_comment }}{% raw %}
# Cloud Provider: {% endraw %}{{ cloud_provider | default('aws') | lower }}{% raw %}

set -euo pipefail

# Volume IDs passed from Terraform/Ansible (sorted for stable ordering)
VOLUME_IDS=({% endraw %}{{ volume_ids_rendered }}{% raw %})
VOLUME_COUNT={% endraw %}{{ volume_ids_list | length }}{% raw %}

# Target symlink prefix
SYMLINK_PREFIX="/dev/exasol_data_"
CLOUD_PROVIDER="{% endraw %}{{ cloud_provider | default('aws') | lower }}{% raw %}"
shopt -s nullglob

# Log function
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | systemd-cat -t exasol-data-symlinks -p info
}

log "Starting Exasol data volume symlink creation"
log "Detected cloud provider: $CLOUD_PROVIDER"

# Common utility functions
log_available_devices() {
    local header="$1"
    shift
    log "$header"
    local found=false
    for pattern in "$@"; do
        for entry in $pattern; do
            found=true
            local resolved
            resolved="$(readlink -f "$entry" 2>/dev/null || echo '?')"
            log "  $entry -> $resolved"
        done
    done
    if [[ "$found" = false ]]; then
        log "  (none found)"
    fi
}

find_device_via_patterns() {
    local vol_id="$1"
    shift
    for pattern in "$@"; do
        for link in $pattern; do
            [[ ! -e "$link" ]] && continue
            local target
            target=$(readlink -f "$link") || continue
            if [[ "$(lsblk -ndo TYPE "$target" 2>/dev/null)" != "disk" ]]; then
                continue
            fi
            echo "$target"
            return 0
        done
    done
    return 1
}

# Provider-specific initialization and device discovery
# Each provider implements its own discovery logic in separate functions
# This allows for clean separation and easy extension for new providers
# 
# To add a new provider:
# 1. Create templates/ansible/exasol-data-symlinks-<provider>.sh.j2
# 2. Implement these three functions:
#    - provider_init_discovery(): Initialize and discover available devices
#    - provider_find_device(vol_id, volume_index): Find device for specific volume
#    - provider_log_available_devices(): Log available devices for debugging
# 3. Add provider-specific comments for future agent modifications

{% endraw %}{% set provider_template = 'exasol-data-symlinks-' + (cloud_provider | default('aws') | lower) + '.sh.j2' %}
{% if provider_template in ['exasol-data-symlinks-aws.sh.j2', 'exasol-data-symlinks-gcp.sh.j2', 'exasol-data-symlinks-azure.sh.j2', 'exasol-data-symlinks-hetzner.sh.j2', 'exasol-data-symlinks-digitalocean.sh.j2', 'exasol-data-symlinks-libvirt.sh.j2', 'exasol-data-symlinks-exoscale.sh.j2', 'exasol-data-symlinks-oci.sh.j2'] %}
{% include provider_template %}
{% else %}
# Unknown provider - perform discovery and fail
log "Unknown cloud provider '$CLOUD_PROVIDER' - no template available"
log "Performing system discovery for template creation"
{% include 'exasol-data-symlinks-generic.sh.j2' %}
{% endif %}{% raw %}

# Discovery function for debugging failed provider templates
# This captures comprehensive system information when device mapping fails
dump_system_discovery_on_failure() {
{% include 'exasol-data-symlinks-generic.sh.j2' %}
    dump_system_discovery
}

# Remove any existing symlinks
for link in ${SYMLINK_PREFIX}*; do
    if [ -L "$link" ]; then
        rm -f "$link"
        log "Removed stale symlink: $link"
    fi
done

# Initialize provider-specific discovery
# This function is implemented in each provider-specific template
provider_init_discovery

# Create symlinks for each volume in sorted order
# ONLY for unmounted volumes (to prevent overwriting OS or other mounted filesystems)
disk_idx=1
for vol_id in "${VOLUME_IDS[@]}"; do
    # Get device path using provider-specific function
    # This function is implemented in each provider-specific template
    target_device=$(provider_find_device "$vol_id" "$((disk_idx - 1))")

    if [[ -z "$target_device" ]]; then
        log "ERROR: Could not map volume $vol_id for provider $CLOUD_PROVIDER"
        # Provider-specific error logging function
        provider_log_available_devices
        
        # Dump comprehensive system discovery for analysis
        log "Performing system discovery for debugging..."
        dump_system_discovery_on_failure
        
        log "FATAL: Device mapping failed - check discovery data in /var/log/exasol-discovery-*"
        exit 1
    fi

    if [[ "$(lsblk -ndo TYPE "$target_device" 2>/dev/null)" != "disk" ]]; then
        log "SKIPPING: $target_device (volume: $vol_id) - resolved device is not a disk"
        continue
    fi

    # Skip if mounted at system paths (/, /boot, /var, etc.) but allow /mnt
    # Note: Data volumes formatted by Ansible are typically mounted at /mnt/<volume-name>
    if lsblk -nlo MOUNTPOINT "$target_device" | grep -q -E '^/(|boot|var|usr|opt|home|tmp|etc)(/|$)'; then
        log "SKIPPING: $target_device (volume: $vol_id) - has system partitions mounted (likely OS volume)"
        continue
    fi

    symlink_name=$(printf "${SYMLINK_PREFIX}%02d" "$disk_idx")
    ln -sf "$target_device" "$symlink_name"
    log "Created symlink: $symlink_name -> $target_device (volume: $vol_id)"
    ((disk_idx++))
done

symlink_count=$((disk_idx - 1))
log "Successfully created $symlink_count Exasol data volume symlinks ($VOLUME_COUNT volumes configured, skipped mounted volumes)"
exit 0
{%- endraw %}

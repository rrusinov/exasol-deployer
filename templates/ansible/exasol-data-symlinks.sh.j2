{% raw -%}
#!/usr/bin/env bash
# This script creates stable /dev/exasol_data_* symlinks for data volumes
# It runs on boot via systemd to ensure symlinks persist across reboots
#
# Generated by Ansible - DO NOT EDIT MANUALLY
# Volume IDs: {% endraw %}{{ volume_ids_comment }}{% raw %}

set -euo pipefail

# Volume IDs passed from Terraform/Ansible (sorted for stable ordering)
VOLUME_IDS=({% endraw %}{{ volume_ids_rendered }}{% raw %})
VOLUME_COUNT={% endraw %}{{ volume_ids_list | length }}{% raw %}

# Target symlink prefix
SYMLINK_PREFIX="/dev/exasol_data_"
CLOUD_PROVIDER="{% endraw %}{{ cloud_provider | default('aws') | lower }}{% raw %}"
shopt -s nullglob

# Log function
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | systemd-cat -t exasol-data-symlinks -p info
}

log "Starting Exasol data volume symlink creation"
log "Detected cloud provider: $CLOUD_PROVIDER"

log_available_devices() {
    local header="$1"
    shift
    log "$header"
    local found=false
    for pattern in "$@"; do
        for entry in $pattern; do
            found=true
            local resolved
            resolved="$(readlink -f "$entry" 2>/dev/null || echo '?')"
            log "  $entry -> $resolved"
        done
    done
    if [[ "$found" = false ]]; then
        log "  (none found)"
    fi
}

find_device_via_patterns() {
    local vol_id="$1"
    shift
    for pattern in "$@"; do
        for link in $pattern; do
            [[ ! -e "$link" ]] && continue
            local target
            target=$(readlink -f "$link") || continue
            if [[ "$(lsblk -ndo TYPE "$target" 2>/dev/null)" != "disk" ]]; then
                continue
            fi
            echo "$target"
            return 0
        done
    done
    return 1
}

declare -a LIBVIRT_DATA_DEVICES=()
if [[ "$CLOUD_PROVIDER" == "libvirt" ]]; then
    while IFS= read -r dev; do
        [[ ! -b "$dev" ]] && continue
        # Skip mounted devices (e.g., root at /dev/vda)
        if lsblk -nlo MOUNTPOINT "$dev" 2>/dev/null | grep -q '^/'; then
            continue
        fi
        resolved="$(readlink -f "$dev" 2>/dev/null || echo "")"
        [[ -n "$resolved" ]] && LIBVIRT_DATA_DEVICES+=("$resolved")
    done < <(for dev in /dev/vd[b-z]; do [[ -e "$dev" ]] && echo "$dev"; done | sort -u)

    if (( ${#LIBVIRT_DATA_DEVICES[@]} == 0 )); then
        log "WARNING: No libvirt virtio data devices discovered (expected $VOLUME_COUNT)"
    else
        log "Discovered ${#LIBVIRT_DATA_DEVICES[@]} libvirt virtio data devices: ${LIBVIRT_DATA_DEVICES[*]}"
    fi
fi

declare -a AZURE_LUN_LINKS=()
AZURE_LUN_INDEX=0
AZURE_LUN_COUNT=0
if [[ "$CLOUD_PROVIDER" == "azure" ]]; then
    # Azure disks may appear under either of these paths.
    # Newer agents expose them via /dev/disk/azure/data/by-lun/*
    # Older agents use /dev/disk/azure/scsi1/lun*
    # Wait up to 60 seconds for any of those patterns to become visible.
    wait_secs=60
    while (( wait_secs > 0 )) && ! (compgen -G "/dev/disk/azure/data/by-lun/*" > /dev/null || compgen -G "/dev/disk/azure/scsi1/lun*" > /dev/null); do
        log "Waiting for Azure LUN devices... $wait_secs seconds remaining"
        sleep 5
        ((wait_secs-=5))
    done
    
    # Collect Azure LUN links from possible locations (simplified approach to avoid hanging)
    # Newer Azure agents expose disks under /dev/disk/azure/data/by-lun/*
    # Fall back to the older /dev/disk/azure/scsi1/lun* path.
    AZURE_LUN_LINKS=()
    AZURE_LUN_COUNT=0
    
    # Collect all matching links first
    declare -a temp_links=()
    for link in /dev/disk/azure/data/by-lun/* /dev/disk/azure/scsi1/lun*; do
        if [[ -e "$link" ]]; then
            temp_links+=("$link")
        fi
    done
    
    # Sort the links for consistent ordering
    if (( ${#temp_links[@]} > 0 )); then
        mapfile -t AZURE_LUN_LINKS < <(printf '%s\n' "${temp_links[@]}" | sort)
        AZURE_LUN_COUNT=${#AZURE_LUN_LINKS[@]}
    fi
    
    if ((AZURE_LUN_COUNT == 0)); then
        log "WARNING: Azure provider detected but no /dev/disk/azure/scsi1/lun* entries found after waiting"
    else
        log "Discovered $AZURE_LUN_COUNT Azure LUN devices"
    fi
fi

# Remove any existing symlinks
for link in ${SYMLINK_PREFIX}*; do
    if [ -L "$link" ]; then
        rm -f "$link"
        log "Removed stale symlink: $link"
    fi
done

# Create symlinks for each volume in sorted order
# ONLY for unmounted volumes (to prevent overwriting OS or other mounted filesystems)
disk_idx=1
for vol_id in "${VOLUME_IDS[@]}"; do
    target_device=""
    case "$CLOUD_PROVIDER" in
        aws)
            vol_id_short="${vol_id//-/}"
            target_device=$(find_device_via_patterns "$vol_id" "/dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_${vol_id_short}*") || true
            ;;
        gcp)
            disk_name="${vol_id##*/}"
            [[ -z "$disk_name" ]] && disk_name="$vol_id"
            target_device=$(find_device_via_patterns "$vol_id" "/dev/disk/by-id/google-${disk_name}" "/dev/disk/by-id/google-persistent-disk-${disk_name}") || true
            ;;
        hetzner)
            target_device=$(find_device_via_patterns "$vol_id" "/dev/disk/by-id/scsi-0HC_Volume_${vol_id}" "/dev/disk/by-id/scsi-0HC_Volume_${vol_id}-*" "/dev/disk/by-id/scsi-0HC_Volume_${vol_id}_*") || true
            ;;
        digitalocean)
            vol_id_clean="${vol_id//-/}"
            target_device=$(find_device_via_patterns "$vol_id" \
                "/dev/disk/by-id/scsi-0DO_Volume_${vol_id}" \
                "/dev/disk/by-id/scsi-0DO_Volume_volume-${vol_id}" \
                "/dev/disk/by-id/scsi-0DO_Volume_${vol_id_clean}" \
                "/dev/disk/by-id/scsi-0DO_Volume_volume-${vol_id_clean}") || true
            ;;
        azure)
            if ((AZURE_LUN_COUNT == 0)); then
                log "ERROR: Azure provider detected but no LUN devices discovered"
                exit 1
            fi
            if ((AZURE_LUN_INDEX >= AZURE_LUN_COUNT)); then
                log "ERROR: Not enough Azure data disks discovered (expected $VOLUME_COUNT, found $AZURE_LUN_COUNT)"
                exit 1
            fi
            
            # Enhanced Azure disk detection with IMDS verification
            # Try to get disk information from Azure IMDS for verification
            imds_disk_info=""
            if command -v curl >/dev/null 2>&1; then
                imds_url="http://169.254.169.254/metadata/instance/compute/storageProfile/dataDisks?api-version=2021-02-01"
                # Add a timeout to prevent hanging
                imds_disk_info=$(curl -s -H Metadata:true --max-time 3 "$imds_url" 2>/dev/null | grep -v "^$" || true)
                if [[ -n "$imds_disk_info" ]] && [[ "$imds_disk_info" != "[]" ]]; then
                    log "Retrieved disk information from Azure IMDS for verification"
                fi
            fi
            
            lun_link="${AZURE_LUN_LINKS[$AZURE_LUN_INDEX]}"
            # Fix for set -e: use : $((expression)) to prevent exit on non-zero result
            : $((AZURE_LUN_INDEX++))
            target_device=$(readlink -f "$lun_link") || target_device=""
            
            # Log disk information for debugging
            if [[ -n "$imds_disk_info" ]] && [[ "$imds_disk_info" != "[]" ]]; then
                log "IMDS disk info available for LUN ${AZURE_LUN_INDEX}: $lun_link -> $target_device"
            else
                log "Mapping LUN link $lun_link to device $target_device (no IMDS verification available)"
            fi
            ;;
        libvirt)
            idx=$((disk_idx - 1))
            if (( idx < ${#LIBVIRT_DATA_DEVICES[@]} )); then
                target_device="${LIBVIRT_DATA_DEVICES[$idx]}"
            else
                log "ERROR: Not enough libvirt virtio data devices discovered (expected index $idx)"
                log_available_devices "Available virtio devices:" "/dev/vd[b-z]" "/dev/disk/by-id/virtio-*"
                exit 1
            fi
            ;;
        *)
            log "ERROR: Unsupported cloud provider '$CLOUD_PROVIDER'"
            exit 1
            ;;
    esac

    if [[ -z "$target_device" ]]; then
        log "ERROR: Could not map volume $vol_id for provider $CLOUD_PROVIDER"
        case "$CLOUD_PROVIDER" in
            aws)
                log_available_devices "Available AWS NVMe volumes:" "/dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_*"
                ;;
            gcp)
                log_available_devices "Available GCP disks:" "/dev/disk/by-id/google-*"
                ;;
            hetzner)
                log_available_devices "Available Hetzner disks:" "/dev/disk/by-id/scsi-0HC_Volume_*"
                ;;
            digitalocean)
                log_available_devices "Available DigitalOcean disks:" "/dev/disk/by-id/scsi-0DO_Volume_*"
                ;;
            azure)
                log_available_devices "Available Azure LUN links:" "/dev/disk/azure/scsi1/lun*"
                ;;
        esac
        exit 1
    fi

    if [[ "$(lsblk -ndo TYPE "$target_device" 2>/dev/null)" != "disk" ]]; then
        log "SKIPPING: $target_device (volume: $vol_id) - resolved device is not a disk"
        continue
    fi

    # Skip if mounted at system paths (/, /boot, /var, etc.) but allow /mnt
    # Note: Data volumes formatted by Ansible are typically mounted at /mnt/<volume-name>
    if lsblk -nlo MOUNTPOINT "$target_device" | grep -q -E '^/(|boot|var|usr|opt|home|tmp|etc)(/|$)'; then
        log "SKIPPING: $target_device (volume: $vol_id) - has system partitions mounted (likely OS volume)"
        continue
    fi

    symlink_name=$(printf "${SYMLINK_PREFIX}%02d" "$disk_idx")
    ln -sf "$target_device" "$symlink_name"
    log "Created symlink: $symlink_name -> $target_device (volume: $vol_id)"
    ((disk_idx++))
done

symlink_count=$((disk_idx - 1))
log "Successfully created $symlink_count Exasol data volume symlinks ($VOLUME_COUNT volumes configured, skipped mounted volumes)"
exit 0
{%- endraw %}

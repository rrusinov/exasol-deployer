{% raw -%}
#!/usr/bin/env bash
# This script sets up GRE tunnel mesh network for Exasol multicast support
# It runs on boot via systemd to ensure GRE network is available
#
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

GRE_IP="{% endraw %}{{ gre_ip }}{% raw %}"
GRE_NETWORK="10.254.0.0/16"
LOCAL_PRIVATE_IP="{% endraw %}{{ local_private_ip }}{% raw %}"
PRIVATE_IFACE=$(ip -o -4 addr show | awk -v ip="$LOCAL_PRIVATE_IP" '$4 ~ ip"/" {print $2; exit}')
PRIVATE_IFACE=${PRIVATE_IFACE:-enp7s0}
BRIDGE_IF="grebr0"
GRE_PREFIX="${GRE_NETWORK#*/}"
BRIDGE_READY_RETRIES=90

PEERS=(
{% endraw %}{% for peer in gre_peers %}
"gre{{ loop.index + 1 }}:{{ peer.ip }}"
{% endfor %}{% raw %})

wait_for_local_ip() {
  for _ in $(seq 1 30); do
    if ip -4 addr show "$PRIVATE_IFACE" | grep -q "$LOCAL_PRIVATE_IP"; then
      return 0
    fi
    sleep 1
  done
  echo "Local IP $LOCAL_PRIVATE_IP not present on $PRIVATE_IFACE" >&2
  return 1
}

ensure_bridge() {
  if ! ip link show "$BRIDGE_IF" >/dev/null 2>&1; then
    ip link add name "$BRIDGE_IF" type bridge
  fi
  # Enable STP to avoid broadcast loops in the GRE mesh
  ip link set "$BRIDGE_IF" type bridge stp_state 1
  ip addr flush dev "$BRIDGE_IF"
  ip addr replace "$GRE_IP/$GRE_PREFIX" dev "$BRIDGE_IF"
  ip link set "$BRIDGE_IF" up
  ip link set "$BRIDGE_IF" multicast on
  if [[ -f /sys/class/net/${BRIDGE_IF}/bridge/multicast_snooping ]]; then
    echo 0 > "/sys/class/net/${BRIDGE_IF}/bridge/multicast_snooping"
  fi
  ip route replace 224.0.0.0/4 dev "$BRIDGE_IF"
}

wait_for_bridge_ready() {
  # Wait for grebr0 to have the expected IP and be UP
  for _ in $(seq 1 "$BRIDGE_READY_RETRIES"); do
    # Re-assert link state and address in case another manager toggled it
    ip link set "$BRIDGE_IF" up >/dev/null 2>&1 || true
    ip addr replace "$GRE_IP/$GRE_PREFIX" dev "$BRIDGE_IF" >/dev/null 2>&1 || true

    if ip -4 addr show "$BRIDGE_IF" | grep -q "$GRE_IP/$GRE_PREFIX" && \
       ip link show "$BRIDGE_IF" | grep -q "state UP"; then
      return 0
    fi
    sleep 1
  done
  echo "GRE bridge $BRIDGE_IF with $GRE_IP/$GRE_PREFIX not ready" >&2
  ip -4 addr show "$BRIDGE_IF" >&2 || true
  ip link show "$BRIDGE_IF" >&2 || true
  return 1
}

ensure_tunnel() {
  local name="$1"
  local remote="$2"

  # Delete any existing tunnel with this name
  ip link del "$name" >/dev/null 2>&1 || true

  # Find and delete any existing tunnel with the same remote/local endpoints
  # This handles cleanup of old tunnels that might have different names
  local existing_tunnel=$(ip -d link show type gretap 2>/dev/null | \
    awk -v rem="$remote" -v loc="$LOCAL_PRIVATE_IP" \
    '/^[0-9]+:/ {iface=$2; sub(/@.*/, "", iface); sub(/:$/, "", iface)}
     /gretap remote/ && $3 == rem && $5 == loc {print iface; exit}')

  if [[ -n "$existing_tunnel" && "$existing_tunnel" != "$name" ]]; then
    echo "Removing existing tunnel $existing_tunnel with same endpoints" >&2
    ip link del "$existing_tunnel" >/dev/null 2>&1 || true
  fi

  # Create the tunnel
  ip link add "$name" type gretap remote "$remote" local "$LOCAL_PRIVATE_IP" ttl 255
  ip link set "$name" up
  ip link set "$name" multicast on
  ip link set "$name" master "$BRIDGE_IF"
}

wait_for_peer_connectivity() {
  local remote="$1"
  # Retry until a 10-packet ping succeeds
  for _ in $(seq 1 30); do
    if ping -I "$BRIDGE_IF" -c 10 -w 20 "$remote" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1
  done
  echo "GRE peer $remote not reachable over $BRIDGE_IF" >&2
  return 1
}

main() {
  wait_for_local_ip
  ensure_bridge
  wait_for_bridge_ready
  for peer in "${PEERS[@]}"; do
    IFS=":" read -r name remote <<<"$peer"
    ensure_tunnel "$name" "$remote"
    wait_for_peer_connectivity "$remote"
  done
}

main
{% endraw -%}

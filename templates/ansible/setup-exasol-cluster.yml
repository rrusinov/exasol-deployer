---
# ==============================================================================
# PLAY 1: GATHER FACTS FROM ALL HOSTS
# This ensures that network information for all nodes is available to the next play.
# ==============================================================================
- name: Play 1 - Gather Host Facts
  hosts: exasol_nodes
  become: yes
  tasks:
    - name: Ensure all host facts are gathered
      ansible.builtin.setup:

# ==============================================================================
# PLAY 2: SETUP AND CONFIGURE EXASOL CLUSTER
# This play runs serially (one node at a time) to perform the configuration.
# ==============================================================================
- name: Play 2 - Setup and Configure Exasol Cluster
  hosts: exasol_nodes
  become: yes
  gather_facts: no # Facts were already gathered in the first play
  serial: 1

  vars:
    # --- User and Path Configuration ---
    exa_user: "exasol"

  tasks:
    # ==============================================================================
    # LOAD DEPLOYMENT CONFIGURATION
    # ==============================================================================
    - name: Load credentials and configuration
      ansible.builtin.set_fact:
        deployment_config: "{{ lookup('file', playbook_dir + '/../.credentials.json') | from_json }}"
      delegate_to: "{{ ansible_play_hosts[0] }}"
      run_once: true

    - name: Set configuration variables
      ansible.builtin.set_fact:
        exa_db_password: "{{ deployment_config.db_password }}"
        exa_admin_password: "{{ deployment_config.adminui_password }}"
        db_download_url: "{{ deployment_config.db_download_url }}"
        c4_download_url: "{{ deployment_config.c4_download_url }}"
        exa_working_copy: "{{ deployment_config.db_working_copy | default('@' + (deployment_config.db_download_url | basename | regex_replace('\\.tar\\.gz$', ''))) }}"
      delegate_to: "{{ ansible_play_hosts[0] }}"
      run_once: true

    - name: Determine artifact locality
      ansible.builtin.set_fact:
        db_is_local: "{{ db_download_url.startswith('file://') }}"
        c4_is_local: "{{ c4_download_url.startswith('file://') }}"
      delegate_to: "{{ ansible_play_hosts[0] }}"
      run_once: true

    - name: Derive local artifact paths
      ansible.builtin.set_fact:
        db_local_path: "{{ db_is_local | ternary(db_download_url | regex_replace('^file://', ''), '') }}"
        c4_local_path: "{{ c4_is_local | ternary(c4_download_url | regex_replace('^file://', ''), '') }}"
      delegate_to: "{{ ansible_play_hosts[0] }}"
      run_once: true

    - name: Derive artifact filenames
      ansible.builtin.set_fact:
        db_artifact_filename: "{{ (db_local_path | basename) if (db_is_local | bool) else (db_download_url | basename) }}"
        c4_artifact_filename: "{{ (c4_local_path | basename) if (c4_is_local | bool) else (c4_download_url | basename) }}"
      delegate_to: "{{ ansible_play_hosts[0] }}"
      run_once: true

    # ==============================================================================
    # SECTION 1: INITIAL NODE & NETWORK SETUP
    # ==============================================================================
    - name: "SECTION 1: Initial Node & Network Setup"
      block:
        - name: Wait for system to be ready
          ansible.builtin.wait_for_connection:
            timeout: 300

        - name: Set hostname to n11, n12, etc.
          ansible.builtin.hostname:
            name: "n{{ ansible_play_hosts.index(inventory_hostname) + 11 }}"

        - name: Update apt cache
          ansible.builtin.apt:
            update_cache: yes
            cache_valid_time: 3600

        - name: Install required system packages via apt
          ansible.builtin.apt:
            name:
              - parted
              - lvm2
              - python3-passlib # Required for password generation
            state: present

        - name: Build hosts file entry for all nodes in the cluster
          ansible.builtin.lineinfile:
            path: /etc/hosts
            regexp: "^{{ hostvars[item]['ansible_default_ipv4']['address'] }}.*"
            line: "{{ hostvars[item]['ansible_default_ipv4']['address'] }} n{{ ansible_play_hosts.index(item) + 11 }}"
            state: present
          loop: "{{ ansible_play_hosts }}"

    # ==============================================================================
    # SECTION 2: CONFIGURE SSH FOR INTER-NODE COMMUNICATION
    # ==============================================================================
    # NOTE: The exasol user is now created via cloud-init during instance boot.
    # This section only handles SSH key generation and distribution.
    - name: Generate a single password for the exasol user
      ansible.builtin.set_fact:
        random_image_pass: "{{ lookup('password', '/dev/null length=16 chars=ascii_letters,digits') }}"
      run_once: true

    - name: "SECTION 2: Configure SSH for Inter-Node Communication"
      block:
        - name: Generate SSH key for exasol user on n11
          community.crypto.openssh_keypair:
            path: "/home/{{ exa_user }}/.ssh/id_rsa"
            owner: "{{ exa_user }}"
            group: "{{ exa_user }}"
          delegate_to: "{{ ansible_play_hosts[0] }}"
          run_once: true

        - name: Fetch the exasol user public key from n11
          ansible.builtin.slurp:
            src: "/home/{{ exa_user }}/.ssh/id_rsa.pub"
          register: exasol_user_pub_key
          delegate_to: "{{ ansible_play_hosts[0] }}"
          run_once: true

        - name: Distribute n11's exasol public key to all nodes
          ansible.posix.authorized_key:
            user: "{{ exa_user }}"
            state: present
            key: "{{ exasol_user_pub_key['content'] | b64decode }}"

    # ==============================================================================
    # SECTION 3A: DISCOVER DATA DISKS AND CREATE SYMLINKS (RUNS ON EVERY NODE)
    # ==============================================================================
    - name: "SECTION 3A: Discover data disks and create /dev/exasol_data_* links"
      block:
        - name: Parse data volume IDs from inventory
          ansible.builtin.set_fact:
            volume_ids_list: "{{ data_volume_ids | from_json if data_volume_ids is string else data_volume_ids }}"

        - name: Install symlink creation script for boot persistence
          ansible.builtin.template:
            src: exasol-data-symlinks.sh.j2
            dest: /usr/local/bin/exasol-data-symlinks.sh
            owner: root
            group: root
            mode: '0755'

        - name: Install systemd service for symlink creation on boot
          ansible.builtin.copy:
            src: exasol-data-symlinks.service
            dest: /etc/systemd/system/exasol-data-symlinks.service
            owner: root
            group: root
            mode: '0644'
          notify: Reload systemd

        - name: Enable and start exasol-data-symlinks service
          ansible.builtin.systemd:
            name: exasol-data-symlinks.service
            enabled: yes
            daemon_reload: yes
            state: started

        - name: Discover existing /dev/exasol_data_* symlinks (sorted)
          ansible.builtin.shell:
            cmd: >-
              shopt -s nullglob;
              symlinks=(/dev/exasol_data_*);
              if [ {% raw %}${#symlinks[@]}{% endraw %} -eq 0 ]; then
                echo "ERROR: No /dev/exasol_data_* symlinks found" >&2;
                exit 1;
              fi;
              printf '%s\n' "{% raw %}${symlinks[@]}{% endraw %}" | sort
            executable: /bin/bash
          register: data_disks_result
          changed_when: false
          failed_when: data_disks_result.rc != 0

        - name: Record data disk symlink paths for this host (in sorted order)
          ansible.builtin.set_fact:
            host_data_disk_paths: "{{ data_disks_result.stdout_lines }}"

  handlers:
    - name: Reload systemd
      ansible.builtin.systemd:
        daemon_reload: yes

# ==============================================================================
# PLAY 3: FINAL CONFIGURATION AND SOFTWARE UPLOAD (Runs on primary node only)
# ==============================================================================
- name: Play 3 - Final Configuration and Software Upload
  hosts: "{{ groups['exasol_nodes'][0] }}"
  become: yes
  gather_facts: no

  vars:
    exa_user: "exasol"

  tasks:
    - name: Gather Exasol data disk symlinks from primary node
      ansible.builtin.shell:
        cmd: "ls -1 /dev/exasol_data_*"
        executable: /bin/bash
      register: exasol_symlinks
      changed_when: false

    - name: Ensure data disk symlinks exist on primary node
      ansible.builtin.assert:
        that:
          - exasol_symlinks.stdout_lines | length > 0
        fail_msg: "No /dev/exasol_data_* symlinks found on {{ inventory_hostname }}"

    - name: Consolidate data disk symlink paths into a single string
      ansible.builtin.set_fact:
        data_disk_paths: "{{ exasol_symlinks.stdout_lines | join(' ') }}"

    - name: Create final Exasol config file from template
      ansible.builtin.template:
        src: "{{ playbook_dir }}/config.j2"
        dest: "/home/{{ exa_user }}/config"
        owner: "{{ exa_user }}"
        group: "{{ exa_user }}"
        mode: '0644'
      vars:
        internal_ips: "{{ groups['exasol_nodes'] | map('extract', hostvars, ['ansible_default_ipv4', 'address']) | join(' ') }}"
        external_ips: "{{ groups['exasol_nodes'] | map('extract', hostvars, 'ansible_host') | join(' ') }}"
        data_disk_paths_var: "{{ data_disk_paths }}"
        exa_image_password: "{{ random_image_pass }}"
        exa_working_copy: "{{ exa_working_copy }}"

    - name: Create installation directory on primary node
      ansible.builtin.file:
        path: "/home/{{ exa_user }}/exasol-release"
        state: directory
        owner: "{{ exa_user }}"
        group: "{{ exa_user }}"
        mode: '0755'

    - name: Move generated config file into place
      ansible.builtin.command:
        cmd: "mv /home/{{ exa_user }}/config /home/{{ exa_user }}/exasol-release/config"
        creates: "/home/{{ exa_user }}/exasol-release/config"

    - name: Transfer local Exasol database tarball
      when: db_is_local | bool
      ansible.builtin.copy:
        src: "{{ db_local_path }}"
        dest: "/home/{{ exa_user }}/exasol-release/{{ db_artifact_filename }}"
        owner: "{{ exa_user }}"
        group: "{{ exa_user }}"
        mode: '0644'

    - name: Download Exasol database tarball
      when: not (db_is_local | bool)
      ansible.builtin.get_url:
        url: "{{ db_download_url }}"
        dest: "/home/{{ exa_user }}/exasol-release/{{ db_artifact_filename }}"
        owner: "{{ exa_user }}"
        group: "{{ exa_user }}"
        mode: '0644'
      register: db_download
      retries: 3
      delay: 5

    - name: Transfer local c4 binary
      when: c4_is_local | bool
      ansible.builtin.copy:
        src: "{{ c4_local_path }}"
        dest: "/home/{{ exa_user }}/exasol-release/{{ c4_artifact_filename }}"
        owner: "{{ exa_user }}"
        group: "{{ exa_user }}"
        mode: '0755'

    - name: Download c4 binary
      when: not (c4_is_local | bool)
      ansible.builtin.get_url:
        url: "{{ c4_download_url }}"
        dest: "/home/{{ exa_user }}/exasol-release/{{ c4_artifact_filename }}"
        owner: "{{ exa_user }}"
        group: "{{ exa_user }}"
        mode: '0755'
      register: c4_download
      retries: 3
      delay: 5

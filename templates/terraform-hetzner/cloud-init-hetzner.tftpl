${base_cloud_init}

# ==============================================================================
# GRE Tunnel Mesh Network Setup for Multicast Support
# ==============================================================================
# Hetzner assigns /32 addresses which breaks multicast subnet detection in Exasol.
# Solution: Create GRE tunnel mesh with proper /24 subnet where multicast works natively.
# Physical IPs: Used for tunnel endpoints
# GRE IPs (10.254.0.0/24): Used for Exasol clustering with native multicast support

GRE_IP="${gre_ip}"
GRE_NETWORK="10.254.0.0/24"
LOCAL_PRIVATE_IP="${local_private_ip}"

echo "Setting up GRE tunnel mesh for multicast..."
echo "  GRE IP: $GRE_IP"
echo "  GRE Network: $GRE_NETWORK"

# Enable IP forwarding (required for GRE)
sysctl -w net.ipv4.ip_forward=1
echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf

# Load GRE kernel module
modprobe ip_gre
echo "ip_gre" >> /etc/modules

# Create a bridge interface for the GRE network before attaching tunnels (idempotent)
if ! ip link show grebr0 >/dev/null 2>&1; then
  ip link add name grebr0 type bridge
fi
ip addr replace $GRE_IP/24 dev grebr0
ip link set grebr0 up
ip link set grebr0 multicast on
# Enable STP to prevent broadcast loops
ip link set grebr0 type bridge stp_state 1
# Disable multicast snooping so multicast floods to all GRE members
if [[ -f /sys/class/net/grebr0/bridge/multicast_snooping ]]; then
  echo 0 > /sys/class/net/grebr0/bridge/multicast_snooping
fi

# Add multicast route via grebr0
ip route replace 224.0.0.0/4 dev grebr0

# Create GRE TAP tunnels to each peer (layer-2 capable for multicast)
TUNNEL_COUNT=0
%{ for peer in peer_endpoints ~}
%{ if !peer.is_self ~}

echo "  Creating GRE tunnel to ${peer.ip} (${peer.gre_ip})..."

# Create GRE TAP tunnel (ethernet over GRE), idempotent
if ! ip link show gre${index(peer_endpoints, peer) + 1} >/dev/null 2>&1; then
  ip link add gre${index(peer_endpoints, peer) + 1} type gretap remote ${peer.ip} local $LOCAL_PRIVATE_IP ttl 255
fi

# Configure tunnel interface
ip link set gre${index(peer_endpoints, peer) + 1} up
ip link set gre${index(peer_endpoints, peer) + 1} multicast on
ip link set gre${index(peer_endpoints, peer) + 1} master grebr0

TUNNEL_COUNT=$((TUNNEL_COUNT + 1))

%{ endif ~}
%{ endfor ~}

echo "  Created $TUNNEL_COUNT GRE tunnels"
echo ""

# Make GRE configuration persistent with systemd-networkd
mkdir -p /etc/systemd/network

# Create netdev file for bridge
cat > /etc/systemd/network/10-grebr0.netdev <<NETDEV_CONFIG
[NetDev]
Name=grebr0
Kind=bridge
NETDEV_CONFIG

# Create network file for bridge
cat > /etc/systemd/network/10-grebr0.network <<NETWORK_CONFIG
[Match]
Name=grebr0

[Network]
Address=$GRE_IP/24
MulticastDNS=yes
Multicast=on
IPv6AcceptRA=no

[Bridge]
STP=yes
MulticastSnooping=no

[Route]
Destination=224.0.0.0/4
NETWORK_CONFIG

# Create GRE tunnel netdev files
%{ for peer in peer_endpoints ~}
%{ if !peer.is_self ~}
cat > /etc/systemd/network/20-gre${index(peer_endpoints, peer) + 1}.netdev <<GRE_NETDEV
[NetDev]
Name=gre${index(peer_endpoints, peer) + 1}
Kind=gretap

[Tunnel]
Local=$LOCAL_PRIVATE_IP
Remote=${peer.ip}
TTL=255
GRE_NETDEV

cat > /etc/systemd/network/20-gre${index(peer_endpoints, peer) + 1}.network <<GRE_NETWORK
[Match]
Name=gre${index(peer_endpoints, peer) + 1}

[Network]
MulticastDNS=yes
Bridge=grebr0
GRE_NETWORK

%{ endif ~}
%{ endfor ~}

# Enable and restart systemd-networkd
systemctl enable systemd-networkd
systemctl restart systemd-networkd

# Wait for tunnels to stabilize
sleep 3

# Verify GRE setup
echo "GRE interface status:"
ip addr show grebr0
echo ""
echo "GRE tunnels:"
ip -d link show | grep -A 3 "gre[0-9]"
echo ""
echo "GRE routes:"
ip route | grep gre
echo ""

echo "GRE mesh network setup complete!"
echo "Exasol should use GRE IP $GRE_IP for clustering"
echo "Multicast will work natively over the GRE mesh"

# GRE supports native multicast - no forwarder needed!

# ------------------------------------------------------------------------------
# Make GRE setup resilient across reboots / stop-start cycles
# ------------------------------------------------------------------------------
cat > /usr/local/bin/setup-gre-mesh.sh <<GRE_SETUP
#!/usr/bin/env bash
set -euo pipefail

GRE_IP="${gre_ip}"
GRE_NETWORK="10.254.0.0/24"
LOCAL_PRIVATE_IP="${local_private_ip}"
PRIVATE_IFACE=$(ip -o -4 addr show | awk -v ip="$$LOCAL_PRIVATE_IP" '$4 ~ ip"/" {print $2; exit}')
PRIVATE_IFACE=$${PRIVATE_IFACE:-enp7s0}
BRIDGE_IF="grebr0"

PEERS=(
%{ for peer in peer_endpoints ~}
%{ if !peer.is_self ~}
"gre${index(peer_endpoints, peer) + 1}:${peer.ip}"
%{ endif ~}
%{ endfor ~}
)

wait_for_local_ip() {
  for _ in $(seq 1 30); do
    if ip -4 addr show "$$PRIVATE_IFACE" | grep -q "$$LOCAL_PRIVATE_IP"; then
      return 0
    fi
    sleep 1
  done
  echo "Local IP $$LOCAL_PRIVATE_IP not present on $$PRIVATE_IFACE" >&2
  return 1
}

ensure_bridge() {
  if ! ip link show "$$BRIDGE_IF" >/dev/null 2>&1; then
    ip link add name "$$BRIDGE_IF" type bridge
  fi
  # Enable STP to avoid broadcast loops in the GRE mesh
  ip link set "$$BRIDGE_IF" type bridge stp_state 1
  if ! ip addr show "$$BRIDGE_IF" | grep -q "$$GRE_IP/24"; then
    ip addr flush dev "$$BRIDGE_IF"
    ip addr add "$$GRE_IP/24" dev "$$BRIDGE_IF"
  fi
  ip link set "$$BRIDGE_IF" up
  ip link set "$$BRIDGE_IF" multicast on
  if [[ -f /sys/class/net/$${BRIDGE_IF}/bridge/multicast_snooping ]]; then
    echo 0 > "/sys/class/net/$${BRIDGE_IF}/bridge/multicast_snooping"
  fi
  ip route replace 224.0.0.0/4 dev "$$BRIDGE_IF"
}

ensure_tunnel() {
  local name="$1"
  local remote="$2"
  ip link del "$name" >/dev/null 2>&1 || true
  ip link add "$name" type gretap remote "$remote" local "$LOCAL_PRIVATE_IP" ttl 255
  ip link set "$name" up
  ip link set "$name" multicast on
  ip link set "$name" master "$BRIDGE_IF"
}

main() {
  wait_for_local_ip
  ensure_bridge
  for peer in "$${PEERS[@]}"; do
    IFS=":" read -r name remote <<<"$peer"
    ensure_tunnel "$name" "$remote"
  done
}

main
GRE_SETUP

chmod +x /usr/local/bin/setup-gre-mesh.sh

cat > /etc/systemd/system/gre-mesh.service <<'GRE_SERVICE'
[Unit]
Description=Ensure GRE mesh overlay for Exasol cluster
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/setup-gre-mesh.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
GRE_SERVICE

systemctl daemon-reload
systemctl enable gre-mesh.service
systemctl start gre-mesh.service
